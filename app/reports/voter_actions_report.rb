class VoterActionsReport
  attr_accessor :items

  # set up the report generation, probably using the helper method
  def initialize(attr = {})
    # read in params, set attrs
  end

  # create the report when so commanded
  def generate(format,period)

    # use the provided method to get the rows on which to report
    # this gets voters within the specified period
    votersInPeriod = ReportsHelper.get_report_items(period)

    # do the actual processing
    retval = ''       # what we return
    accumVtrActions, accumVtrForms, accumVtrNoteTypes  = Hash.new()# where we accumulate data to report
    accumArray = [accumVtrActions, accumVtrForms, accumVtrNoteTypes]; #where we will put all the different accums

    puts accumArray

    #Here is where to insert new logic!
    votersInPeriod.each do |vtr|
      accumArray.each do |accum|

        # if we already have the keyadd 1 to tally
        if accum == accumVtrActions
          accum.has_key?(vtr.action) ? accum[vtr.action] += 1 : accum[vtr.action] = 0 
        elsif accum == accumVtrForms
          accum.has_key?(vtr.form) ? accum[vtr.form] += 1 : accum[vtr.form] = 0 
        elsif accum == accumVtrNoteTypes
          accum.has_key?(vtr.notes) ? accum[vtr.notes] += 1 : accum[vtr.notes] = 0 
        else puts "invalid accum in VoterActionsReport::generate"
      end
    end
  end

    # Brendan's old code
    # rows.each do |row|
    #   k = row['voterid']
    #   accum[k] = 0 if accum[k].nil?
    #   accum[k] += 1
    # end

    # send the processed data to the appropriate output routine
    if format == 'html'
      return html_output(accumVtrActions, accumVtrForms, accumVtrNoteTypes)
    end
    if format == 'csv'
      return csv_output(accumVtrActions, accumVtrForms, accumVtrNoteTypes)
    end

    return "Programming error in report generation"
  end


  # create the HTML version of the report and display it in the browser
  # let's modify this so that it can take multiple hashes (one for action, one for form, etc.)
  def html_output(*accums)
    retval = ''
    headerStartIndex = 0
    headerLength = 2
    accums.each { |accum| retval += makeHtmlTable(accum, headerStartIndex, headerLength, true)}
    # return the formatted HTML
    retval
  end

  # let's make this also do percentages
  # we'll modify the accum to have an array for the key that holds the value and it's percent of total
  def calcAccumPercentages(accum)
    total = 0
    # once through to get total
    accum.each do |k, v| total += v
      # another time to do the
      accum.each { |k, v| v = [v, v / total * 100] }
    end
  end
  def makeHtmlTable(accum, headerStartIndex, numHeaders, displayPercentages)
    calcAccumPercentages(accum) if displayPercentages

    # set basic table spacing and padding
    retval = '<table cellspacing="3" cellpadding="3">'
    # linefeed, tr = row, th = header cell (in this case, the first one which is empty)
    retval += "\n<tr><th></th>"
    # output the column headers
    # I18n is internationaliztion gem for translation
    # .t looks up the translation, in this case for column_headers(comes from locales/reports/voter_actions.yml)
    # then iterates through
    I18n.t('VoterActionsReport.column_headers').slice(headerStartIndex, numHeaders).each do |header|
      # adds in the table headers
      retval += "<th>#{header}</th>"
      retval += "<th>Percent Total</th>" if displayPercentages
    end
    # end tag for the table row
    retval += "\n</tr>\n"
    # background
    bg = ''
    count = 0
    # sort_by: Sorts self in place using a set of keys generated by mapping the values in self through the given block.
    # I think it orders by value smallest to largest
    # then places in alternating lightgrey and white bgs
    accum.sort_by {|k,v| v}.reverse.each do |k,v|
      count += 1
      if bg.blank?
        bg = 'lightgrey'
      else
        bg = ''
      end

      # sets background color of table row to bg
      # puts index in table cell and alligns right
      # puts the key in table cell
      # puts value in table cell and alligns right
      # ends row
      retval += "<tr bgcolor=\"#{bg}\"><td align=\"right\">#{count}</td><td>#{k}</td>"
      retval +="<td align=\"right\">#{v[0]}</td></tr>\n" if displayPercentages
      retval +="<td align=\"right\">#{1}</td></tr>\n"

    end
    # closes table
    retval += "</table>\n"

    retval #return formatted html
  end

  # create the CSV version of the report and download it to the client
  # TODO: add support for percentages and multiple tables!
  def csv_output(accum)

    # some day the user id will be added to the filename so that it really works
    # guessing this creates a new file?
    fn = Rails.root.join('public','data','VoterActionsReport.csv')
    # opent the new file (w means write only)
    csv = File.open(fn,"w")

    # output the column headers
    hdrs = Array.new
    I18n.t('VoterActionsReport.column_headers').each do |h|
      # puts header on end of hdrs array, for some reason with triple parens
      hdrs.push('"' + h + '"')
    end
    # puts all the headers at the end of the file
    csv.puts hdrs.join(',')

    # output the corresponding data
    accum.each do |k,v|
      csv.puts "#{k},#{v}"
    end

    csv.close
    # will place a link to the csv file???
    ActionController::Base.helpers.link_to "CSV","/data/VoterActionsReport.csv"
  end
end
